# MemoryPool
c++ 高并发内存池,学习tcmalloc，简化的内存池



## 1、操作系统管理内存(linux)

​		操作系统的内存管理是非常捡漏的，其实抛去c-lib，系统基本上没有提供额外的内存管理。或者说操作系统并没有向我们负责内存上的优化，在这方面操作系统仅仅保证虚拟内存到物理内存的映射。所以关于内存分配方面的系统调用主要就三个——brk、sbrk、mmap。

​		那么有人可能疑惑malloc不是操作系统的内存管理吗？其实，真不是。c-lib确实算是最进阶操作系统的库了，但是c-lib中的malloc也是封装了一个内存池的，但是c-lib跨平台，所以就让人默认以为malloc就是内存的最底层管理。就像我在学习的tcmalloc，就是谷歌发明的一个内存管理技术。和malloc算是平级的。而且在《APUE》中内存管理那一章，不同平台还采用不同的内存池技术，比如jemalloc、ptmalloc之类的。

​		那么直接从操作系统获取内存就会导致系统调用。尤其是内存申请和释放这种高频操作。那么就有一种方法就是内核态申请一大块儿内存，到用户态来进行管理。

## 2、用户态内存管理

​		到了用户态就不关心什么系统调用的详情了，但是我们可能遇到另一个问题。想一个情况，我们向系统一下申请了10MB内存，但是一个小时只用了1MB，那么就有9MB空间遭受了浪费（占着茅坑不拉屎），这种情况我们可以归还内存。但是假如说出现了另一种情况，我们频繁从我们用户态的管理者处申请释放内存，就会导致从系统申请来的内存存在很多内碎片。内碎片的存在也浪费了空间。

​		所以我们综合起来要设计一个内存池要考虑一些问题。

## 3、高并发内存池设计要点

### 		1)如何管理内存

###		2)如何减少内碎片问题
### 3)如何实现高并发的情况下减少锁竞争



## 4、分级管理

​		经过测试发现，大于64kb的内存可以直接从系统中申请。（不要问为什么，可以测试一下）

​		所以tcmalloc中就出现了一种高校的管理体系。还减少了锁的竞争。小于64kb的小块儿内存不能竞争。同时还要进行内存回收和

内存紧缩。

​		所以分三个模块：ThreadCache、CentralCache、PageCache

- ThreadCache

​		线程缓存，每个线程中都存在一个，相当于给每个线程一块儿资源，在线程内动态管理不需要锁竞争了。

- CentralCache

​		中心缓存，被所有线程都可以访问到，所以这里是加锁的，还管理内存的申请和释放。但是线程缓存已经存在了，中心缓存就不会被频繁的竞争。

- PageCache

​		页缓存，直接与操作系统交互，是CentralCache的上级缓存。负责从系统申请大块儿内存，分割成Span并派发给CentralCache，还会回收CentralCache中的内存。在这里还会做内存紧缩。

## 5、感想
    性能很差，优化的想法都没有了，还不如直接用malloc。不过能学点知识。